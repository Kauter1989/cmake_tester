# CMakeList.txt : CMake project for TestEnvironment, include source and define
# project specific logic here.
# see https://habr.com/ru/post/433822/
cmake_minimum_required (VERSION 3.8)

# Add source to this project's executable.
#add_executable (TestEnvironment "TestEnvironment.cpp" "TestEnvironment.h")

# here will be set(STUDPROJNAME ...)

set(STUDADDR "../../../student/build/${STUDPROJNAME}")

# TODO: Add tests and install targets if needed.
# Добавить тесты:

enable_testing()
SET (TestEnvironment_TIMEOUT 100)
add_test(Trivial_RedTest ${PROJECT_NAME} Red ../ex1.png ${STUDADDR} res.png 10 30 2 0 1 1)
add_test(Normal_RedTest ${PROJECT_NAME} Red ../ex1.png ${STUDADDR} res.png 1 3 2 0 1 1)
add_test(Normal_ThresholdTest ${PROJECT_NAME} Threshold ../ex1.png ${STUDADDR} res.png 0 0 2 2)
void operator()( image_data &imgData, area const &ar )
    {
        // alias
        auto cpp = imgData.compPerPixel;
        const int matrixSize = 3;
        std::array<int, matrixSize * matrixSize> indices;

        // pixel - center pixel
        auto applyMedian =
                [&imgData, cpp, &indices, matrixSize]( int pixelX, int pixelY, int matrixSize, int channel ) -> void
        {
            int
                xStart = std::max(0, pixelX - matrixSize / 2),
                yStart = std::max(0, pixelY - matrixSize / 2),
                xEnd = std::min(imgData.w - 1, pixelX + matrixSize / 2),
                yEnd = std::min(imgData.h - 1, pixelY + matrixSize / 2);

            int i = 0;
            for (int y = yStart; y < yEnd; y++)
                for (int x = xStart; x < xEnd; x++)
                    indices[i++] = y * imgData.w * cpp + x + channel;

            std::sort(indices.begin(),
                      indices.begin() + (yEnd - yStart + 1) * (xEnd - xStart + 1),
                        [&imgData]( int idx1, int idx2 ) -> bool
                        {
                            return imgData.pixels[idx1] < imgData.pixels[idx2];
                        });

            for (int i = 0; i < (yEnd - yStart + 1) * (xEnd - xStart + 1) / 2; i++)
                imgData.pixels[indices[i]] = 0;
        };

        if (cpp == 4 || cpp == 3) {
            int y = ar.top == 0 ? 0 : imgData.h / ar.top;
            int x = ar.left == 0 ? 0 : imgData.w / ar.left;
            for (; y < imgData.h / ar.bottom; y++)
                for (; x < (imgData.w / ar.right) * cpp; x += cpp)
                    for (int c = 0; c < cpp; c++)
                        applyMedian(x, y, 3, c);
        }
    }
# Установить поведение тестов:
set_tests_properties(Trivial_FirstTest
PROPERTIES TIMEOUT ${TestEnvironment_TIMEOUT})

set_tests_properties(Trivial_FirstTest PROPERTIES
PASS_REGULAR_EXPRESSION "OK OK"
FAIL_REGULAR_EXPRESSION "BAD: Too many bad pixels: [d]{1,}")

set_tests_properties(Normal_SecondTest PROPERTIES
PASS_REGULAR_EXPRESSION "OK OK"
FAIL_REGULAR_EXPRESSION "BAD:Too many bad pixels: [d]{1,}")
